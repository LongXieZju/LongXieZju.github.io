<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python装饰器]]></title>
    <url>%2F2018%2F04%2F12%2F2018-04-12-Python-decorator%2F</url>
    <content type="text"><![CDATA[装饰器由于函数也是个对象，而且函数变量也可以赋值给变量，所以通过变量也能够调用该函数。123456&gt;&gt;&gt; def now():··· print("This is a function")···&gt;&gt;&gt; f = now()&gt;&gt;&gt; f()'This is a function' 函数对象有一个name属性，可以拿到函数的名字1234&gt;&gt;&gt; now.__name__'now'&gt;&gt;&gt; f.__name__'now' 现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：123@logdef now(): print("This is a function") 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：123&gt;&gt;&gt; now()call now():'This is a function' 把@log放到now()函数的定义处，相当于执行了语句：1now = log(now) 由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，即在log()函数中返回的wrapper()函数。 wrapper()函数的参数法定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，下出来会更复杂。比如，要自定义log的文本：1234567def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下：123@log('execute')def now(): print("This is a function") 执行结果如下：123&gt;&gt;&gt; now()excute now():'This is a function' 和两层嵌套的decorator相比，3层嵌套的效果是这样的：1&gt;&gt;&gt; now = log('execute')(now) 我们来剖析上面的语句，首先执行log(&#39;execute&#39;)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。 以上两种decorator的定义都没有问题，但还差最后一步。因为我们降了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的&#39;now&#39;变成了&#39;wrapper&#39;：12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写wrapper.__name__ = func.__name__这样的代码，见`@functools.wraps`]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙大玉泉Ubuntu14.04/16.04有线网VPN配置]]></title>
    <url>%2F2017%2F06%2F06%2F2017-06-06-Ubuntu_VPN%2F</url>
    <content type="text"><![CDATA[摘要浙大网络连接主要有两步： 设置IP和DNS连接内网 通过VPN连接外网 内网连接 (1) 在终端输入命令ifconfig 查看使用的网卡（作者本人的为eth0） (2) 使用如下命令打开文件配置IP和DNS1sudo gedit /etc/network/interfaces (3) 在打开的文件中输入如下代码（注：寝室联网还需要绑定MAC地址）1234567auto eth0iface eth0 inet statichwaddress ether /你的MAC地址/address /你的ip/netmask 255.255.255.0gateway /你的网关/dns-nameservers 10.10.0.21 (4) 此时如果重启会显示设备未托管，直接修改文件NetworkManager.conf 1234sudo gedit /etc/NetworkManager/NetworkManager.conf将文件中原本的false改为true[ifupdown]managed=true (5) 保存重启后在终端输入ping 10.10.0.21如果返回下图结果则表示内网连接成功 外网连接(1) 外网连接非常简单，需要安装xl2tpd包，在98上有下载地址http://www.cc98.org/dispbbs.asp?boardID=212&amp;ID=4651082&amp;page=1 (2) 安装之前需要先删除原来的xl2tpd包1sudo dpkg --purge xl2tpd (3) 可以直接双击下载下来的包安装，也可以使用命令安装1sudo dpkg -i xl2tpd_1.2.5+zju-1_amd64.deb (4) 安装完后就可以配置用户名和密码上网1sudo vpn-connect -c /用户名后需要加@a/ (5) 网络连接命令1sudo vpn-connect (6) 断开网络连接命令1sudo vpn-connect -d (7) 这样就可以使用有线上外网了 注意：每次软件更新会造成无法使用的情况，此时需要再重新安装，比较麻烦，所以需要设置不更新xl2tpd。在终端输入1sudo echo &quot;xl2tpd hold&quot; | dpkg --set-selections 然后查看不更新的软件包1sudo dpkg --get-selections | grep hold 看到如下结果就表示成功，此时再更新软件也不会造成错误1xl2tpd hold 本文主要参考了以下两个人的博客： http://blog.csdn.net/u013611347/article/details/51824813 http://blog.sina.com.cn/s/blog_9a80e5180101d9yq.html]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
